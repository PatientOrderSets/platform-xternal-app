Platform Xternal App
====================

This sample application will hopefully demonstrate how to get an application integrated with PatientOrdersets Platform.
Through the use of JWT and OAuth2 all applications should have access to API end points provided by our platform.

Libraries
---------

This project uses the following libraries:

1. [Devise](https://github.com/plataformatec/devise)    - A well known library for user authentication
2. [JSON-JWT](https://github.com/nov/json-jwt)          - A well maintained ruby JWT library parser
3. [OAuth2](https://github.com/intridea/oauth2)         - A ruby OAuth2 client library

Setting Up The Client Application
---------------------------------

### Authenticating the user

Assuming you're using Devise we need to apply a filter that will handle the JWT login process before the default Devise
logic kicks in. To do this we apply a `before_filter` before the application's Devise authenticate call. For example,
the sample application defines the authenticate call, thus the resulting `ApplicationController` should look like the
following:

```ruby
class ApplicationController < ActionController::Base
  # Prevent CSRF attacks by raising an exception.
  # For APIs, you may want to use :null_session instead.
  protect_from_forgery with: :exception

  before_filter :authenticate_user_from_ep_platform
  before_filter :authenticate_user!

  # ... other things go here ...

  def authenticate_user_from_ep_platform
    if params[:jwt]
      jwt_token = JSON::JWT.decode params[:jwt], Rails.configuration.doorkeeper_application_id

      # You will want to check to see if the JWT token is generated by the right application.
      # That is, you need to check that the aud, iss claims are what you expect.
      # I've omitted here as this is just a sample application.

      user = User.find_or_create_by(upn: jwt_token['upn']) do |user|
        user.first_name = jwt_token['first_name']
        user.last_name = jwt_token['first_name']
        user.email = jwt_token['email']
        user.doorkeeper_request_token = jwt_token['oauth_request_token']
      end

      user.save if user.changed?

      sign_in user
    end
  end
end
```

How this works is that it will sign the user in and when the `before_filter :authenticate_user!` executes the application
already knows the user has been signed in and just lets the request go through to final end point.

This logic was taken from this [post](https://gist.github.com/josevalim/fb706b1e933ef01e4fb6) which describes how Devise
removed the `TokenAuthenticatable` strategy and shows how Devise users should be handling authentication through tokens.

### What's in the JWT

JWT is a growing standard that is being used by larger companies. If you are interested in the spec I encourage you to go check it out.

A JWT is comprised of 3 sections delimited by a '.' where each section is base64 encoded. The first part is considered the JWT header, the middle section is the JWT body, and the last section is the signed portion of the header and the body together.

Here is an example of a JWT token that the Platform application produces

```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vcGF0aWVudG9zLmF3LmRldi5wb3MiLCJhdWQiOiJYdGVybmFsIEFwcCIsIm5iZiI6MTM4MTQxOTc1NSwiZXhwIjoxMzgxNDQ5NjAwLCJpYXQiOjEzODE0MTk3NTUsImp0aSI6IjEzODE0MTk3NTUvZ2s2bnQycHQ5ZmplbDdjaWM3dmg5N3U0bHJvcGphdHcxMXplZ3U3Nm4zZXJnb3g2c3pjOXNuZjZheTBld3Q5dCIsImVtYWlsIjoiYWxmcmVkLndvbmdAcGF0aWVudG9yZGVyc2V0cy5jb20iLCJmaXJzdF9uYW1lIjoiQWxmcmVkIiwibGFzdF9uYW1lIjoiV29uZyIsInVwbiI6ImFsZnJlZC53b25nQGNvcnAucGF0aWVudG9yZGVyc2V0cy5jb20iLCJjbGllbnRfbmFtZSI6IlBhdGllbnRPUyIsImVudHJ5cG9pbnRfY2xpZW50X2lkIjozLCJvYXV0aF9yZXF1ZXN0X3Rva2VuIjoiMTVmNTAyNjdlM2NkNjE0OWM3ZTZhNzUzYzVmYzQwZjkzYzY3ZmMxNDdjNjgzZjYxNjQxMjBjN2QyNzM4MWUzZiIsIm9hdXRoX3JlcXVlc3RfdG9rZW5fZXhwIjo2MDB9.0I7zm9XaqyFFMctc2VXKCxF4SdGDl8zzdHq5tO4Rodo
```

The decoded version looks like this:

###### Header

```json
{"typ":"JWT","alg":"HS256"}
```

###### Body

```json
{
    "iss":"http://patientos.aw.dev.pos",
    "aud":"Xternal App",
    "nbf":1381419755,
    "exp":1381449600,
    "iat":1381419755,
    "jti":"1381419755/gk6nt2pt9fjel7cic7vh97u4lropjatw11zegu76n3ergox6szc9snf6ay0ewt9t",
    "email":"alfred.wong@patientordersets.com",
    "first_name":"Alfred",
    "last_name":"Wong",
    "upn":"alfred.wong@corp.patientordersets.com",
    "client_name":"PatientOS",
    "entrypoint_client_id":3,
    "oauth_request_token":"15f50267e3cd6149c7e6a753c5fc40f93c67fc147c683f6164120c7d27381e3f",
    "oauth_request_token_exp":600
}
```

###### Footer

```
Ўګ!E1\UxIуtz
```

#### What you need to know

The following claims (reserved claims by the standard) are probably of most interest to you:

* `iss` - Who generated the token
* `aud` - Who the token is intended for
* `nbf` - 'Not Before Time' where the token is not valid before this time (seconds since epoch)
* `exp` - 'Expiry' where token is not valid after this time (seconds since epoch)
* `iat` - 'Issued At' when the token was issued (seconds since epoch)
* `jti` - Unique identifier for the token (clients can check to see if this token was used already)
* `oauth_request_token` - The token in which you use to actually get a valid OAuth2 token

The `JSON::JWT.decode` call will handle all of the decoding and validating that the token has not been tampered with.
The `decode` method takes in the JWT string along with a key that signed the token. The key for each JWT is the
generated application uid when registering the application with the EP Platform.

It is up to the client to validate the claims in the token are valid.

Once you have validated the claims it is important to save the `oauth_request_token` with the user in which you can use
at a later time to retrieve the actual OAuth2 access token. Once you use the request token to retrieve the access token
the request token is automatically invalidated and no longer usable.

### Making Requests with the OAuth2 Token

There are a couple of configuration tasks that need to be done before you can actually start requesting tokens.

#### Setting Up

